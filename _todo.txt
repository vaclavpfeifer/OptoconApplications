- implement logging
  ~DONE do wrapper over another engine so we can switch
  ~ default logger behaviour needs to be consolidated!!!

- convert project to makefile or QTproj file or Cmake?
  ~ to have same basic settings (to not export qt proj every time some change to vcxproj is made)
  

- add architecture design 
  ~ e.g. high level class diagram in EA?


- testing solution
  ~ unit vs. integration tests
  ~ selection of testing engine (have previous experience with google test)
  ~ define use cases


- Migrate to cross-platfrom development
  ~ ideally build for selected platform - directly on win, or indirectly by sending data and invoking compile & link on target platform


- Deployment process
  ~ distribute source binary with only necessary QT libs?
  ~ 

DONE (disconect is not necessary):- Check wheteher for complex object creation (including signal/slot setup) is necessary to do disconect!!

- Check that there are no memory leaks -- valgrind?

- Deployment process
  ~ create whole new qmake proj file (from which even vcxProj files can be generated - simmilar to cmake)
  ~ qmake is able to do deployment/install as well

DONE : - Disable main frame on window leave only content - i.e. disable frame with X button  


## COMANDS - TODO & PROBLEMS
- COMMANDS should return some enum status instead of pure INT
 - Should we return AbstractCommand by parameter instead? and execute on View??
 -- Or execure after signal for UI update is done? If i will have command which will do some UI setup that could be a poblem!!

 - If command is still executing and i will triger/click same button? should I wait until the previous one is completed and dismiss the command? or what should be the default behaviour??
	~ I should keep some sort of mapping whether thread finished before new thread is spammed? 
	
	~ !!! Or assign executer directly / either sync/async and those informations can be set-up directly


- Architecture:
  ~ create items in Abstract View for all items that could exists and do move the common logic to abstract class which should now work with local variables from abstract class.
    The only thing that must be done is registration in concrete view class + before setting/do some action test must be performed that concrete item has been set...
    + make method virtual so they could be override in case of need
    
     ~ do the check that items exists at the beggining or on the fly? Or switch to std::map!!!


-
